{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertHardhatInvariant = exports.applyErrorMessageTemplate = exports.NomicLabsHardhatPluginError = exports.HardhatPluginError = exports.HardhatError = exports.CustomError = void 0;\nconst caller_package_1 = require(\"../util/caller-package\");\nconst strings_1 = require(\"../util/strings\");\nconst errors_list_1 = require(\"./errors-list\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nclass CustomError extends Error {\n  constructor(message, parent) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    super(message);\n    this.parent = parent;\n    this.name = this.constructor.name;\n    // We do this to avoid including the constructor in the stack trace\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this._stack = this.stack ?? \"\";\n    Object.defineProperty(this, \"stack\", {\n      get: () => this[inspect]()\n    });\n  }\n  [inspect]() {\n    let str = this._stack;\n    if (this.parent !== undefined) {\n      const parentAsAny = this.parent;\n      const causeString = parentAsAny[inspect]?.() ?? parentAsAny.inspect?.() ?? parentAsAny.stack ?? parentAsAny.toString();\n      const nestedCauseStr = causeString.split(\"\\n\").map(line => `    ${line}`).join(\"\\n\").trim();\n      str += `\n\n    Caused by: ${nestedCauseStr}`;\n    }\n    return str;\n  }\n}\nexports.CustomError = CustomError;\nclass HardhatError extends CustomError {\n  constructor(errorDescriptor) {\n    let messageArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parentError = arguments.length > 2 ? arguments[2] : undefined;\n    const prefix = `${(0, errors_list_1.getErrorCode)(errorDescriptor)}: `;\n    const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);\n    super(prefix + formattedMessage, parentError);\n    this.errorDescriptor = errorDescriptor;\n    this.number = errorDescriptor.number;\n    this.messageArguments = messageArguments;\n    this._isHardhatError = true;\n    Object.setPrototypeOf(this, HardhatError.prototype);\n  }\n  static isHardhatError(other) {\n    return other !== undefined && other !== null && other._isHardhatError === true;\n  }\n  static isHardhatErrorType(other, descriptor) {\n    return HardhatError.isHardhatError(other) && other.errorDescriptor.number === descriptor.number;\n  }\n}\nexports.HardhatError = HardhatError;\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\nclass HardhatPluginError extends CustomError {\n  constructor(pluginNameOrMessage, messageOrParent, parent) {\n    if (typeof messageOrParent === \"string\") {\n      super(messageOrParent, parent);\n      this.pluginName = pluginNameOrMessage;\n    } else {\n      super(pluginNameOrMessage, messageOrParent);\n      this.pluginName = (0, caller_package_1.getClosestCallerPackage)();\n    }\n    this._isHardhatPluginError = true;\n    Object.setPrototypeOf(this, HardhatPluginError.prototype);\n  }\n  static isHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isHardhatPluginError === true;\n  }\n}\nexports.HardhatPluginError = HardhatPluginError;\nclass NomicLabsHardhatPluginError extends HardhatPluginError {\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  constructor(pluginName, message, parent) {\n    let shouldBeReported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(pluginName, message, parent);\n    this.shouldBeReported = shouldBeReported;\n    this._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n  }\n  static isNomicLabsHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isNomicLabsHardhatPluginError === true;\n  }\n}\nexports.NomicLabsHardhatPluginError = NomicLabsHardhatPluginError;\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\nfunction applyErrorMessageTemplate(template, values) {\n  return _applyErrorMessageTemplate(template, values, false);\n}\nexports.applyErrorMessageTemplate = applyErrorMessageTemplate;\nfunction _applyErrorMessageTemplate(template, values, isRecursiveCall) {\n  if (!isRecursiveCall) {\n    for (const variableName of Object.keys(values)) {\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName\n        });\n      }\n      const variableTag = `%${variableName}%`;\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName\n        });\n      }\n    }\n  }\n  if (template.includes(\"%%\")) {\n    return template.split(\"%%\").map(part => _applyErrorMessageTemplate(part, values, true)).join(\"%\");\n  }\n  for (const variableName of Object.keys(values)) {\n    let value;\n    if (values[variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[variableName].toString();\n    }\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n    const variableTag = `%${variableName}%`;\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG, {\n        variable: variableName\n      });\n    }\n    template = (0, strings_1.replaceAll)(template, variableTag, value);\n  }\n  return template;\n}\nfunction assertHardhatInvariant(invariant, message) {\n  if (!invariant) {\n    throw new HardhatError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, {\n      message\n    });\n  }\n}\nexports.assertHardhatInvariant = assertHardhatInvariant;","map":{"version":3,"names":["caller_package_1","require","strings_1","errors_list_1","inspect","Symbol","for","CustomError","Error","constructor","message","parent","name","captureStackTrace","undefined","_stack","stack","Object","defineProperty","get","str","parentAsAny","causeString","toString","nestedCauseStr","split","map","line","join","trim","exports","HardhatError","errorDescriptor","messageArguments","arguments","length","parentError","prefix","getErrorCode","formattedMessage","applyErrorMessageTemplate","number","_isHardhatError","setPrototypeOf","prototype","isHardhatError","other","isHardhatErrorType","descriptor","HardhatPluginError","pluginNameOrMessage","messageOrParent","pluginName","getClosestCallerPackage","_isHardhatPluginError","isHardhatPluginError","NomicLabsHardhatPluginError","shouldBeReported","_isNomicLabsHardhatPluginError","isNomicLabsHardhatPluginError","template","values","_applyErrorMessageTemplate","isRecursiveCall","variableName","keys","match","ERRORS","INTERNAL","TEMPLATE_INVALID_VARIABLE_NAME","variable","variableTag","includes","TEMPLATE_VARIABLE_TAG_MISSING","part","value","TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG","replaceAll","assertHardhatInvariant","invariant","GENERAL","ASSERTION_ERROR"],"sources":["/home/sumanjit/projects/eth_daddy/node_modules/hardhat/src/internal/core/errors.ts"],"sourcesContent":["import { getClosestCallerPackage } from \"../util/caller-package\";\nimport { replaceAll } from \"../util/strings\";\n\nimport { ErrorDescriptor, ERRORS, getErrorCode } from \"./errors-list\";\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nexport class CustomError extends Error {\n  private _stack: string;\n\n  constructor(message: string, public readonly parent?: Error) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    super(message);\n\n    this.name = this.constructor.name;\n\n    // We do this to avoid including the constructor in the stack trace\n    if ((Error as any).captureStackTrace !== undefined) {\n      (Error as any).captureStackTrace(this, this.constructor);\n    }\n\n    this._stack = this.stack ?? \"\";\n\n    Object.defineProperty(this, \"stack\", {\n      get: () => this[inspect](),\n    });\n  }\n\n  public [inspect](): string {\n    let str = this._stack;\n    if (this.parent !== undefined) {\n      const parentAsAny = this.parent as any;\n      const causeString =\n        parentAsAny[inspect]?.() ??\n        parentAsAny.inspect?.() ??\n        parentAsAny.stack ??\n        parentAsAny.toString();\n      const nestedCauseStr = causeString\n        .split(\"\\n\")\n        .map((line: string) => `    ${line}`)\n        .join(\"\\n\")\n        .trim();\n      str += `\n\n    Caused by: ${nestedCauseStr}`;\n    }\n    return str;\n  }\n}\n\nexport class HardhatError extends CustomError {\n  public static isHardhatError(other: any): other is HardhatError {\n    return (\n      other !== undefined && other !== null && other._isHardhatError === true\n    );\n  }\n\n  public static isHardhatErrorType(\n    other: any,\n    descriptor: ErrorDescriptor\n  ): other is HardhatError {\n    return (\n      HardhatError.isHardhatError(other) &&\n      other.errorDescriptor.number === descriptor.number\n    );\n  }\n\n  public readonly errorDescriptor: ErrorDescriptor;\n  public readonly number: number;\n  public readonly messageArguments: Record<string, any>;\n\n  private readonly _isHardhatError: boolean;\n\n  constructor(\n    errorDescriptor: ErrorDescriptor,\n    messageArguments: Record<string, string | number> = {},\n    parentError?: Error\n  ) {\n    const prefix = `${getErrorCode(errorDescriptor)}: `;\n\n    const formattedMessage = applyErrorMessageTemplate(\n      errorDescriptor.message,\n      messageArguments\n    );\n\n    super(prefix + formattedMessage, parentError);\n\n    this.errorDescriptor = errorDescriptor;\n    this.number = errorDescriptor.number;\n    this.messageArguments = messageArguments;\n\n    this._isHardhatError = true;\n    Object.setPrototypeOf(this, HardhatError.prototype);\n  }\n}\n\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\nexport class HardhatPluginError extends CustomError {\n  public static isHardhatPluginError(other: any): other is HardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isHardhatPluginError === true\n    );\n  }\n\n  public readonly pluginName: string;\n\n  private readonly _isHardhatPluginError: boolean;\n\n  /**\n   * Creates a HardhatPluginError.\n   *\n   * @param pluginName The name of the plugin.\n   * @param message An error message that will be shown to the user.\n   * @param parent The error that causes this error to be thrown.\n   */\n  constructor(pluginName: string, message: string, parent?: Error);\n\n  /**\n   * A DEPRECATED constructor that automatically obtains the caller package and\n   * use it as plugin name.\n   *\n   * @deprecated Use the above constructor.\n   *\n   * @param message An error message that will be shown to the user.\n   * @param parent The error that causes this error to be thrown.\n   */\n  constructor(message: string, parent?: Error);\n\n  constructor(\n    pluginNameOrMessage: string,\n    messageOrParent?: string | Error,\n    parent?: Error\n  ) {\n    if (typeof messageOrParent === \"string\") {\n      super(messageOrParent, parent);\n      this.pluginName = pluginNameOrMessage;\n    } else {\n      super(pluginNameOrMessage, messageOrParent);\n      this.pluginName = getClosestCallerPackage()!;\n    }\n\n    this._isHardhatPluginError = true;\n    Object.setPrototypeOf(this, HardhatPluginError.prototype);\n  }\n}\n\nexport class NomicLabsHardhatPluginError extends HardhatPluginError {\n  public static isNomicLabsHardhatPluginError(\n    other: any\n  ): other is NomicLabsHardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isNomicLabsHardhatPluginError === true\n    );\n  }\n\n  private readonly _isNomicLabsHardhatPluginError: boolean;\n\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  constructor(\n    pluginName: string,\n    message: string,\n    parent?: Error,\n    public shouldBeReported = false\n  ) {\n    super(pluginName, message, parent);\n\n    this._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n  }\n}\n\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\nexport function applyErrorMessageTemplate(\n  template: string,\n  values: { [templateVar: string]: any }\n): string {\n  return _applyErrorMessageTemplate(template, values, false);\n}\n\nfunction _applyErrorMessageTemplate(\n  template: string,\n  values: { [templateVar: string]: any },\n  isRecursiveCall: boolean\n): string {\n  if (!isRecursiveCall) {\n    for (const variableName of Object.keys(values)) {\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName,\n        });\n      }\n\n      const variableTag = `%${variableName}%`;\n\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName,\n        });\n      }\n    }\n  }\n\n  if (template.includes(\"%%\")) {\n    return template\n      .split(\"%%\")\n      .map((part) => _applyErrorMessageTemplate(part, values, true))\n      .join(\"%\");\n  }\n\n  for (const variableName of Object.keys(values)) {\n    let value: string;\n\n    if (values[variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[variableName].toString();\n    }\n\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n\n    const variableTag = `%${variableName}%`;\n\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(\n        ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG,\n        { variable: variableName }\n      );\n    }\n\n    template = replaceAll(template, variableTag, value);\n  }\n\n  return template;\n}\n\nexport function assertHardhatInvariant(\n  invariant: boolean,\n  message: string\n): asserts invariant {\n  if (!invariant) {\n    throw new HardhatError(ERRORS.GENERAL.ASSERTION_ERROR, { message });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}